package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"strings"
	"text/template"
)

// Template for the script
const tmplScript = `#!/bin/bash
# WARNING: Deletes existing auditd rules & logs
# WARNING: Don't run multiple instances
# Assumes /var/log/audit/ contains auditd logs

trace_start() {
	# Remove existing rules & logs
	sudo auditctl -D
	sudo service auditd rotate
	sudo rm -f /var/log/audit/audit.log.*

	# Add rule
	sudo auditctl -w {{.MonitorDir}} -k icase
}

trace_end() {
	# Delete all rules & cleanup
	sudo auditctl -D
	sudo service auditd rotate

	# Save trace
	sudo ausearch -k icase -r >{{.TraceFile}}
}

# Setup tracing
trap 'trace_end >/dev/null' EXIT
trace_start >/dev/null

# Run command
{{.Cmd}}
`

// Generate auditd traces by running the given command
type Trace struct {
	Cmd        string // commmand to run
	MonitorDir string // which path should auditd to monitor
	ScriptFile string // holds script to generate script
	TraceFile  string // has trace generated by running script
}

// Test: s == ""
func emptyStr(s string) bool {
	return len(strings.Trim(s, "")) == 0
}

func traceErr(e error) error {
	return fmt.Errorf("trace: %v", e)
}

// Create temporary files
func createFile(prefix string) (string, error) {
	// create file
	f, err := os.CreateTemp("", prefix)
	if err != nil {
		return "", traceErr(err)
	}
	tracefile := f.Name()

	// close file
	if err := f.Close(); err != nil {
		return "", traceErr(err)
	}

	return tracefile, nil
}

// If monitordir == "", then use current working directory.
func NewTrace(cmd, monitordir string) (*Trace, error) {
	// By default, monitor current working dir
	if emptyStr(monitordir) {
		monitordir, _ = os.Getwd()
	}

	// create script file
	scriptfile, err := createFile("ncscript-")
	if err != nil {
		return nil, err
	}

	// create trace file
	tracefile, err := createFile("nctrace-")
	if err != nil {
		os.Remove(scriptfile)
		return nil, err
	}

	// Trace
	t := &Trace{
		Cmd:        cmd,
		MonitorDir: monitordir,
		ScriptFile: scriptfile,
		TraceFile:  tracefile,
	}

	// populate script file
	if e := t.generateScript(); e != nil {
		t.Close()
		return nil, e
	}

	return t, nil
}

func (t *Trace) Close() {
	os.Remove(t.ScriptFile)
	os.Remove(t.TraceFile)
}

// Generate script from template
func (t Trace) generateScript() error {
	var buf bytes.Buffer

	// Create template
	tmpl, err := template.New("trace").Parse(tmplScript)
	if err != nil {
		return traceErr(err)
	}

	// Run template
	err = tmpl.Execute(&buf, t)
	if err != nil {
		return traceErr(err)
	}

	// Write to script
	err = ioutil.WriteFile(t.ScriptFile, buf.Bytes(), 0755)
	if err != nil {
		return traceErr(err)
	}

	return nil
}

func (t Trace) Run() error {
	cmd := exec.Command("/bin/bash", t.ScriptFile)

	output, err := cmd.Output()
	fmt.Printf(string(output))
	if err != nil {
		return traceErr(err)
	}

	return nil
}
